
# jdk 
jdk包含 jre 
jre 包含 jvm

# java区分大小写

# 字符和字符串
> * 字符只能至少是一个
> * 字符串可以是空

# 字节 位
> * 计算机的最小信息单位是 位 b
> * 最小存储单元是 字节 B
> * 1B = 8b

# 数据类型
> * java默认的整数类型是int
> * java默认的浮点类型是double

# 字符串是引用类型
> * String s = "12"

# 默认值
> * String null
> * double 0.0
> * int 0

# 变量
> * 变量定义，不赋值，不能使用

# 自动转换
> * double d = 100; // init 自动转换成double
> * boolean 不参与类型转换

# 强制类型转换
> * 大的转换成小的，会丢失数据，没有要求不做
> * 


# 运算
```java
byte a = 1;
a = a + 1; // 损失精度，报错

a = (byte)(a + 1); // 等同于 a += 1;

a += 1;
a++; 这两个不会损失精度

```

# 逻辑运算符
```java
&
|
^ 两边相同为false,不同为true
!
&& 短路与，前为false，后面不执行。比& 提升效率
||


```

# if 条件必须是布尔类型，不能是int

# for嵌套
> * 外循环控制行，内循环控制每行几个
> * break 写在哪个循环，只结束当前循环
> * break 标记，结束外部循环

# Random 类 随机数
```java
import java.util.Random;

Random rn = new Random();
int rnResult = rn.nextInt(100); // 0 -99 随机数，不包括100
double d = rn.nextDouble(); // 0.0 - 1.0 // 不包括1.0，不用指定范围
```

# Scanner 类 提供用户输入
```java
import java.util.Scanner;
Scanner scanner = new Scanner(System.in);
int i = scanner.nextInt(); // 接受键盘输入的整数

String str = scanner.next(); // next() 接受字符串数据
```

# switch 可接受的数据类型
> * JDK1.0 - 1.4 byte short int char
> * JDK.5 byte short int char enum
> * JDK.7 byte short int char enum String

> * case 匹配上，没有break，不会匹配下面，会穿透，一直遇到break，但会执行每个case后面的语句


# 数组，必须有类型，长度固定
> * int[] arr = new int[2];
> * 变量保存的是数组的地址
> * int数组的默认值 0
> * length 值类型 int
## 数组定义方式2
```java
int[] arr = new int[]{1, 2, 3};
// 注意：[]不能写任何内容
```
## 数组定义方式3，用的最多
```java
int[] arr = {1, 2, 3};
```
> 越界，索引值超出


# 二维数组
```java
int[][] arr = {{}, {}};
```



# jvm 对自己的内存分成5个区域
> * 寄存器：内存和CPU之间
> * 本地方法栈：jvm调用系统的功能
> * 方法和数据共享：运行时期class文件进入的地方
> * 方法栈：所有方法运行的时候进入的内存 main
> * 堆：存储数组和对象的地方

jvm方法执行完，自动清空内存



# 方法注意事项
> * 方法不能定义在另一个方法的内部
> * 方法不能重复定义
> * 方法没有返回值，不能直接使用


# 方法的重载
> * 在同一类中，方法名相同，参数列表不同
> * 参数的个数，数据类型，顺序
> * 对于重载的调用，根据参数传递进行区分

> * 重载只和方法名和参数列表有关
> * 和参数变量名、返回值类型、修饰符无关

# 方法的参数
> * 基本类型，传递的是值
> * 引用类型，按地址传递


# 自定义类
> * 类在同一个文件夹，不需要导入包
> * 自定义类的属性有默认值 String null
> * 类中的属性，跟随容器进入堆内存


# ArrayList
> * 存储引用类型，不存储基本类型，没有数量限制
> * ArrayList<Integer> i = new ArrayList<Integer>();
> * 方法
> * add("a")
> * size()
> * get(0)


# char 
> * 取值范围0-65535
> * 两个char类型相加会进行数值运算
> * char + int 会转化成 int
> * 字符 ++ 会变成下一个ascii码值对应的字符

# 对象
> * 对象在堆内存创建后，类的成员变量，跟随对象进入到堆内存中，赋值默认值
> * 类的方法，哪个对象调用，里面的变量指向那个对象

# 成员变量与局部变量
> * 成员变量位置：类中方法外
> * 局部变量位置： 类的方法中或语句内
> * 成员变量有默认初始值
> * 局部变量没有默认值，不赋值不能使用
> * 内存位置不同：成员变量-根据对象进入堆   局部变量-根据自己的方法进入栈内存
> * 生命周期不同：成员变量-跟随对象，在堆中存储，内存等待jvm清理，生命相对较长  局部变量-跟随方法，方法出栈，生命相对较短



# 修饰符
> * private 成员修饰符，不能修饰局部变量
  * 被private修饰的成员，只能在自己本类中使用
  * 对私有变量，提供公共的访问方式：方法
  * 定义方法，对私有变量赋值，方法名必须set开头
  * 取值 get

> * 类中不需要对外提供的内容都私有化，包括属性和方法
> * 以后再描述事物，属性都私有化，并提供get set方法对其访问
> * 注意：私有仅仅是封装的体现形式而已


# this
> * 解决成员变量和局部变量同名问题，this指向调用该方法的对象

# 继承 单继承
> * 子类可以直接使用父类的可继承的属性和方法
> * 不能出现多继承，一个子类只能有一个父类，因为多继承相同的方法，会出现安全问题
> * java支持多层继承，A -> B -> C


# super
> * 调用父类的属性和方法

# 方法的重写（覆盖）
> * 子类和父类方法一模一样
> * 当子类需要父类的功能，而功能主体子类有自己特有的内容时，可以重写父类的发法
> * 注意：子方法的权限大于或等于父类的权限

* 四大权限 public protectd default private  不写默认default ，不能写出来



# 抽象类
> * 不能实例化，不能new
> * 继承抽象类，必须实现抽象类的所有抽象方法
> * 如果子类继承了抽象类，重写了一部分抽象方法，这个子类还是一个抽象类
> * 设计思想：继承体系的完整性，功能的完整性

* 抽象类一定是个父类
* 抽象类可以没有抽象方法，意义：不让该类创建对象，方法可以直接让子类使用
* abstract 不能和private final static 共同使用
* 抽象类中，可以某个方法抽象，别的成员变量和方法还是不变



# 接口
> * 降低类与类之间的耦合性，增强扩展性，优化程序设计
> * 抽象方法固定格式 public abstract，public abstract 写不写都有，实现接口的类得分方法要写public
> * 抽象方法的权限必须是public ，不能变
> * 成员变量：必须是常量 public static final int a =2; public static final 不写也有
> * 接口不可以创建对象
> * 子类必须实现接口所有的抽象方法，子类才可实例化吧。否则子类是一个抽象类

## 接口多实现，没有安全隐患

* 类继承类的同时可以实现多个接口

* 接口与接口之间是继承关系
* 接口可以多继承接口

## 接口思想
* 接口就是暴露出来的规则
* 降低耦合性，增强扩展性

## 接口和抽象类的区别
> * 都位于继承的顶端，用于被其他类继承或实现、
> * 都不能直接实例化
> * 都包含抽象方法，其子类必须覆盖这些抽象方法

* 区别
> * 抽象类为部分方法提供实现，避免子类重复实现这些方法，提高代码重用性，接口只能包含抽象方法
> * 一个类只能继承一个抽象类，却可以实现多个接口（接口弥补了java的单继承）
> * 抽象类是这个事物中应该具备的内容
> * 接口是这个事物中额外的内容

* 二者的选用
> * 优先使用接口，尽量少使用抽象类，降低耦合性
> * 需要定义子类的行为，又要为子类提供共性功能时才选用抽象类

# static final
> * static 直接可以用类名调用
> * final 固定值不变


# 多态
> * 父类引用变量可以指向子类对象
> * 在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法

> * 成员变量，是父类的变量，运行的也是父类发指
> * 成员方法：编译看父类，运行看子类，子类没有看父类

> * 转换 Student s = (Student)(p)



# instanceof 
> * 判断某个对象是不是谁实例化出来的
> * 不能随便写个类
> * 对继承关系的类才有用


# 类的构造方法
> * 方法的名字必须与类名一样
> * 不需要写返回值
> * 没有程序会自动添加，有不会自动添加
> * 先赋值成员变量，再构造方法

> * 构造方法可以重载
> * 构造方法加private 就不能new了
## this()
> * 构造方法内调用其他构造方法 this()
> * this() 必须写在构造方法的第一行

## super() 
> * 调用父类空参数构造
> * 加上参数，调用父类有参数构造
> * 子类的构造方法，默认有super()

父类先进方法区，子类再进









